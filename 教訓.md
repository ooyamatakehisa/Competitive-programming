- 式の途中の掛け算でintの範囲とか超えそうなときはできるだけ式の形を工夫する。
  例えばm,nが10^6ぐらいの数だとしてm^2-n^2の計算はオーバーフローするが(m-n)(m+n)とすることでオーバーフローしない
- 大学入試の整数問題的なアプローチもある
- 与えられた玉n個からから2つの玉をとるとり方はnC2でもいいが、玉を一個ずつ増やして考えていって玉一個のときは0こcnt+=0
  玉2このときは1通りcnt+=1、玉3個のときはcnt+=3-1=2、玉4個のときはcnt+=4-1=3のように考えてもいい
- 計算量的に行けそうなときは全探索もいとわない？ABC165-C
- DFS深さ優先探索をかけるようになろう(上と同じ問題 & ABC167C)
- 数式でxの5乗とかでてきたら O(10^2) とかであっという間にx^5<10^9の範囲の値の全探索できる！困ったら代入して様子見(ABC166D)
- 選ぶ選ばない等の全探索はビット演算で行える。A買うB買わないC買わないD買うのようなパターンは1001のように表せてfor(i,0,1<<n)のようにかける(ABC167C)
- マス目とか行列はちゃんと二次元配列もしくはvecotorで実装する(LINEコードテスト)
- 累積和を用いることでdpを高速化できる！(ABC179D)
- ライブラリを使ってmodのとり忘れをなくす(ABC179D)
- 関数を複数回適用するような問題はグラフ書いてループがあるかも実際に有効グラフみたいなん書いてみる
  やっぱり小さな数とかで例を書いて規則性みつける(ABC179E)
- dp[i] = Σ[j<=i-1]dp[j] = dp[i-1] + dp[i-2] (ABC178D)
- マンハッタン距離は45ど回転の座標変換、絶対値はmaxにもかえれる|a|=max(a,-a) (ABC178E)
- 集合を扱うときはunionfindがいいね！(ABC177D)
- a1, a2, a3, ... ,an < max_a が互いに素かどうかはn^2の比較をするのではなく
  for(i,0,n){ c[a[i]]++; }としてfor(j, 2, max_a){ cnt=0; for(k=j,k<=max_a,k+=j){ cnt+=c[k]; }} で max_a*log(max_a)の計算量

