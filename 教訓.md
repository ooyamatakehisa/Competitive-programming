- 式の途中の掛け算でintの範囲とか超えそうなときはできるだけ式の形を工夫する。
  例えばm,nが10^6ぐらいの数だとしてm^2-n^2の計算はオーバーフローするが(m-n)(m+n)とすることでオーバーフローしない
- 大学入試の整数問題的なアプローチもある
- 与えられた玉n個からから2つの玉をとるとり方はnC2でもいいが、玉を一個ずつ増やして考えていって玉一個のときは0こcnt+=0
  玉2このときは1通りcnt+=1、玉3個のときはcnt+=3-1=2、玉4個のときはcnt+=4-1=3のように考えてもいい
- 計算量的に行けそうなときは全探索もいとわない？ABC165-C
- DFS深さ優先探索をかけるようになろう(上と同じ問題 & ABC167C)
- 数式でxの5乗とかでてきたら O(10^2) とかであっという間にx^5<10^9の範囲の値の全探索できる！困ったら代入して様子見(ABC166D)
- 選ぶ選ばない等の全探索はビット演算で行える。A買うB買わないC買わないD買うのようなパターンは1001のように表せて
  2の4乗通りの数は1<<4としてかけて、Cが選ばれてるかは 1001>>2&1 で判定できる(ABC167C, 173C)
- マス目とか行列はちゃんと二次元配列もしくはvecotorで実装する(LINEコードテスト)
- 累積和を用いることでdpを高速化できる！(ABC179D)
- ライブラリを使ってmodのとり忘れをなくす(ABC179D)
- 関数を複数回適用するような問題はグラフ書いてループがあるかも実際に有効グラフみたいなん書いてみる
  やっぱり小さな数とかで例を書いて規則性みつける、周期性をみつけるやつこの問題参照すべし(ABC179E)
- dp[i] = Σ[j<=i-1]dp[j] = dp[i-1] + dp[i-2] (ABC178D)
- マンハッタン距離は45ど回転の座標変換、絶対値はmaxにもかえれる|a|=max(a,-a) (ABC178E)
- 集合を扱うときはunionfindがいいね！(ABC177D)
- a1, a2, a3, ... ,an < max_a が互いに素かどうかはn^2の比較をするのではなく
  for(i,0,n){ c[a[i]]++; }としてfor(j, 2, max_a){ cnt=0; for(k=j,k<=max_a,k+=j){ cnt+=c[k]; }} で max_a*log(max_a)の計算量
  約数とかの問題とかにも使える (ABC177E)
- 二次元マスの探索系の問題、これを参考にするべし、コストが0と1しかないなら01bfsというのをつかおう(ABC176D)
- Kの倍数か = Kで割り切れるか = Kの割った余りはせいぜいK未満、数列に漸化式（関数）をたてれたらmodの性質的にあまりは周期的になる(ABC174C)
- 答えで二分探索、、ある値を求める問題で10^9くらいの範囲でしぼっていく(ABC174E) (ABC172C)
- しゃくとり法(ABC172C)
- 対称的な連立方程式みたいなやつは、全ての式を足すといいことがある！XORの問題とかだと同じもののXORは0になって特に便利！(ABC171E)
- pairのminはまず一つ目で比べられて次に二つ目でくらべられる！(ABC170C)
- 掛け算する時とかは if(a * b > 120)とかはオーバーフローすることがあるのでif(b > 120 / a)とする(ABC180)